<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pipeline de Données IA22 : Prototype Validé et Architecture de Production Sécurisée</title>
    <style>
        /* CSS pour un rendu professionnel et responsive */
        :root {
            --primary-color: #0056b3;
            --secondary-color: #333;
            --bg-color: #f9f9f9;
            --code-bg: #eef2f8;
            --code-border: #b0c4de;
            --note-bg: #e6f7ff;
            --note-border: #007bff;
        }

        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            color: var(--secondary-color);
            max-width: 950px;
            margin: 20px auto;
            padding: 0 20px;
            background-color: var(--bg-color);
        }
        h1, h2, h3 {
            color: var(--primary-color);
            margin-top: 25px;
            margin-bottom: 10px;
        }
        h1 {
            border-bottom: 3px solid var(--primary-color);
            padding-bottom: 15px;
            text-align: center;
            font-size: 2.2em;
        }
        h2 {
            border-bottom: 1px solid #ccc;
            padding-bottom: 8px;
            font-size: 1.8em;
        }
        h3 {
            font-size: 1.4em;
            margin-top: 20px;
        }
        code {
            font-family: 'Courier New', monospace;
            background-color: var(--code-bg);
            padding: 2px 4px;
            border-radius: 3px;
            font-size: 0.9em;
        }
        pre {
            background-color: var(--code-bg);
            padding: 15px;
            border: 1px solid var(--code-border);
            border-left: 5px solid var(--primary-color);
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            margin-bottom: 20px;
            border-radius: 4px;
        }
        strong {
            color: var(--primary-color);
        }
        ul, ol {
            margin-left: 25px;
            margin-bottom: 10px;
        }
        .abstract, .authors {
            text-align: center;
            margin-bottom: 30px;
        }
        .abstract p {
            font-style: italic;
            font-size: 1.1em;
            max-width: 750px;
            margin: 0 auto;
            padding: 10px;
            border: 1px dashed #ccc;
        }
        .note {
            background-color: var(--note-bg);
            border-left: 4px solid var(--note-border);
            padding: 15px;
            margin: 20px 0;
            border-radius: 4px;
        }
    </style>
</head>
<body>

    <h1>Pipeline de Données IA22 : Prototype Validé et Architecture de Production Sécurisée</h1>

    <div class="authors">
        <h3>Auteur : Mohammed Ilyes ZOUBIROU</h3>
        <p>milyes@netsecurepro.ca</p>
    </div>

    <div class="abstract">
        <h3>Résumé</h3>
        <p>
            Ce document valide la conception d'un pipeline de données léger et automatisé, implémenté sous forme de script Bash, pour le traitement des "signaux IA22" critiques destinés à l'IA embarquée (TFLite). [cite_start]Suite à cette validation, nous présentons une feuille de route détaillée pour la transition de ce prototype vers une architecture de production sécurisée, mettant l'accent sur le cryptage cryptographique robuste, la sérialisation binaire dédiée (Protobuf/FlatBuffers), et la résilience opérationnelle[cite: 1].
        </p>
    </div>

    <hr>

    <h2>1. Validation Fonctionnelle du Prototype</h2>
    <p>Le prototype vise à transformer des données brutes JSON (provenant de capteurs `NeuroSensor-A0x`) en un format compact et "pré-sécurisé" pour l'inférence TFLite.</p>

    <h3>1.1. Étapes du Prototype (`run_ia22_data.sh`)</h3>
    <ul>
        <li>**Génération Brute :** Création de fichiers JSON hétérogènes (`signal_record_x.json`).
            <pre><code>{ "record_id": "1", ..., "device_id": "NeuroSensor-A02", "behavior_class": "Class_2", ... }</code></pre>
        </li>
        <li>**Sérialisation (Simulation) :** Utilisation de `cat | tr -d ' \n\t'` pour supprimer les espaces JSON, simulant une sérialisation binaire pour optimiser la taille.
        </li>
        <li>**Encapsulation (Simulation de Sécurité) :** Utilisation de `gzip -c` pour la compression et l'encapsulation. Le fichier résultant (`.enc.gz`) est compact (réduction d'environ 350 octets à ~130 octets).
        </li>
    </ul>

    <h3>1.2. Conclusion de la Validation</h3>
    <p>Les tests d'exécution ont confirmé que le script est pleinement fonctionnel et atteint ses objectifs d'automatisation et de compactage des données. Cependant, pour la production, la **simulation de sécurité** doit être remplacée par des mesures cryptographiques réelles.</p>

    <h2>2. Architecture de Production : Renforcement de la Sécurité</h2>
    [cite_start]<p>La transition vers la production exige un renforcement critique de la sécurité, remplaçant la compression par un chiffrement et une vérification d'intégrité robustes[cite: 1].</p>

    <h3>2.1. Cryptage Robuste (Confidentialité)</h3>
    <ul>
        [cite_start]<li>**Problème :** `gzip` ne fournit pas de chiffrement sécurisé[cite: 1].</li>
        [cite_start]<li>**Solution :** Intégrer **OpenSSL** pour le chiffrement symétrique **AES-256-CBC**[cite: 1].</li>
    </ul>
    <pre><code>
# Chiffrement AES-256-CBC avec une clé stockée de manière sécurisée (non dans le repo)
openssl enc -aes-256-cbc -salt -in "data.bin" \
            -out "data.enc" \
            -pass file:"$ENCRYPTION_KEY_FILE"
    </code></pre>

    <h3>2.2. Intégrité des Données (Détection d'Altérations)</h3>
    <ul>
        [cite_start]<li>**Problème :** Les données chiffrées peuvent toujours être altérées (bits corrompus) sans être détectées au déchiffrement[cite: 1].</li>
        [cite_start]<li>**Solution :** Utiliser un code d'authentification de message **HMAC (SHA256)** pour signer le fichier chiffré[cite: 1]. [cite_start]Le récepteur vérifie le HMAC pour s'assurer qu'aucune altération n'a eu lieu[cite: 1].</li>
    </ul>
    <pre><code>
# Générer le HMAC du fichier chiffré
openssl dgst -sha256 -hmac "$(cat "$HMAC_KEY_FILE")" \
             -binary "data.enc.gz" \
             > "data.hmac"
    </code></pre>

    <h3>2.3. Gestion des Clés et Sécurisation de l'Environnement</h3>
    [cite_start]<p>Les clés de chiffrement (`ENCRYPTION_KEY_FILE`) et HMAC doivent être gérées via un **KMS (Key Management Service)** ou des variables d'environnement protégées, et jamais codées en dur[cite: 1]. [cite_start]L'exécution du script doit être **conteneurisée (Docker)** pour l'isoler du système hôte[cite: 1].</p>

    <h2>3. Optimisation de la Sérialisation Binaire pour TFLite</h2>
    [cite_start]<p>La performance et la résilience aux changements de schéma nécessitent des formats binaires dédiés[cite: 1].</p>

    <ul>
        [cite_start]<li>**Protobuf (Protocol Buffers) :** Permet une sérialisation compacte, rapide et surtout **schema-driven**, essentielle pour l'évolution rétro-compatible du format des signaux IA22[cite: 1].</li>
        [cite_start]<li>**FlatBuffers :** Format de Google optimal pour les environnements contraints (faible latence/mémoire) car il permet d'accéder aux données sans désérialisation préalable[cite: 1].</li>
    </ul>
    [cite_start]<p>Cette étape implique de remplacer la commande Bash rudimentaire par un appel à un programme externe (Python/C++) dédié à la conversion JSON vers Protobuf[cite: 1].</p>
    <pre><code>
# Appel d'un programme externe pour la sérialisation typée
python3 json_to_protobuf.py "$file" > "$PROCESSED_DATA_DIR/${BASENAME}.bin"
    </code></pre>

    <h2>4. Robustesse Opérationnelle et Flexibilité</h2>
    [cite_start]<p>Un pipeline de production doit gérer les échecs et s'adapter aux changements[cite: 1].</p>

    <h3>4.1. Gestion des Erreurs et Journalisation</h3>
    <ul>
        [cite_start]<li>**Vérification des Commandes :** Utiliser le statut de la dernière commande (`$?`) après chaque opération critique (ex: `openssl enc ... || { echo "ERREUR: Échec..."; exit 1; }`)[cite: 1].</li>
        [cite_start]<li>**Journalisation :** Intégrer la commande `logger` pour envoyer les événements (succès, échecs, étapes clés) au syslog du système pour la surveillance et le suivi[cite: 1].</li>
    </ul>

    <h3>4.2. Paramétrisation</h3>
    <ul>
        [cite_start]<li>Remplacer les chemins et valeurs codées en dur par des **arguments de ligne de commande** ou un **fichier de configuration externe** (`config.conf`)[cite: 1].</li>
        [cite_start]<li>Ajouter un mode **"Dry Run"** pour simuler l'exécution sans modifier le système de fichiers réel[cite: 1].</li>
    </ul>
    <pre><code>
# Utilisation d'un fichier de configuration
source ./config.conf
# ...
if [ "$DRY_RUN" == "false" ]; then
    # Commande réelle
else
    echo "DRY RUN: skipping command"
fi
    </code></pre>

    <div class="note">
        <strong>Conclusion :</strong> Les améliorations proposées transforment le prototype fonctionnel en un composant **robuste, sécurisé et performant**, indispensable pour la gestion des "signaux IA22" sensibles dans un environnement de production d'IA embarquée.
    </div>

</body>
</html>
